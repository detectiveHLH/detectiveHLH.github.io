import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as l,c as d,a as e,b as a,d as n,f as i}from"./app-5a161a5d.js";const c="/images/23092/img-1.jpg",b="/images/23092/img-2.jpg",o="/images/23092/img-3.jpg",m="/images/23092/img-4.jpg",p="/images/23092/img-5.jpg",h={},u=i('<h1 id="webassembly完全入门——了解wasm的前世今身" tabindex="-1"><a class="header-anchor" href="#webassembly完全入门——了解wasm的前世今身" aria-hidden="true">#</a> WebAssembly完全入门——了解wasm的前世今身</h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>接触WebAssembly之后，在google上看了很多资料。感觉对WebAssembly的使用、介绍、意义都说的比较模糊和笼统。感觉看了之后收获没有达到预期，要么是文章中的例子自己去实操不能成功，要么就是不知所云、一脸蒙蔽。本着业务催生技术的态度，这边文章就诞生了。前部分主要是对WebAssembly的背景做一些介绍，WebAssembly是怎么出现的，优势在哪儿。如果想直接开始撸代码试试效果，可以直接跳到最后一个<a href="#WebAssembly%E5%AE%9E%E6%93%8D">板块</a>。</p><h2 id="webassembly是什么" tabindex="-1"><a class="header-anchor" href="#webassembly是什么" aria-hidden="true">#</a> WebAssembly是什么？</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>首先我们给它下个定义。</p><blockquote><p>WebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式</p></blockquote><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h3><p>当然，我知道，即使你看了定义也不知道WebAssembly到底是什么东西。废话不多说，我们通过一个简单的例子来看看WebAssembly到底是什么。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图的左侧是用C++实现的求递归的函数。中间是十六进制的Binary Code。右侧是指令文本。可能有人就问，这跟WebAssembly有个屁的关系？其实，中间的十六进制的Binary Code就是WebAssembly。</p><h3 id="编译目标" tabindex="-1"><a class="header-anchor" href="#编译目标" aria-hidden="true">#</a> 编译目标</h3><p>大家可以看到，其可写性和可读性差到无法想象。那是因为WebAssembly不是用来给各位用手<strong>一行一行撸</strong>的代码，WebAssembly是一个<strong>编译目标</strong>。什么是编译目标？当我们写TypeScript的时候，Webpack最后打包生成的JavaScript文件就是编译目标。可能大家已经猜到了，上图的Binary就是左侧的C++代码经过编译器编译之后的结果。</p><h2 id="webassembly的由来" tabindex="-1"><a class="header-anchor" href="#webassembly的由来" aria-hidden="true">#</a> WebAssembly的由来</h2><h3 id="性能瓶颈" tabindex="-1"><a class="header-anchor" href="#性能瓶颈" aria-hidden="true">#</a> 性能瓶颈</h3><p>在业务需求越来越复杂的现在，前端的开发逻辑越来越复杂，相应的代码量随之变的越来越多。相应的，整个项目的起步的时间越来越长。在性能不好的电脑上，启动一个前端的项目甚至要花上十多秒。这些其实还好，说明前端越来越受到重视，越来越多的人开始进行前端的开发。</p><p>但是除了逻辑复杂、代码量大，还有另一个原因是JavaScript这门语言本身的缺陷，JavaScript没有静态变量类型。这门解释型编程语言的作者Brendan Eich，仓促的创造了这门如果被广泛使用的语言，以至于JavaScript的发展史甚至在某种层面上变成了填坑史。为什么说没有静态类型会降低效率。这会涉及到一些JavaScript引擎的一些知识。</p><h3 id="静态变量类型所带来的问题" tabindex="-1"><a class="header-anchor" href="#静态变量类型所带来的问题" aria-hidden="true">#</a> 静态变量类型所带来的问题</h3><figure><img src="'+b+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这是Microsoft Edge浏览器的JavaScript引擎ChakraCore的结构。我们来看一看我们的JavaScript代码在引擎中会经历什么。</p><ul><li>JavaScript文件会被下载下来。</li><li>然后进入Parser，Parser会把代码转化成AST（抽象语法树）.</li><li>然后根据抽象语法树，Bytecode Compiler字节码编译器会生成引擎能够直接阅读、执行的字节码。</li><li>字节码进入翻译器，将字节码一行一行的翻译成效率十分高的Machine Code.</li></ul><p>在项目运行的过程中，引擎会对执行次数较多的function记性优化，引擎将其代码编译成Machine Code后打包送到顶部的Just-In-Time(JIT) Compiler，下次再执行这个function，就会直接执行编译好的Machine Code。但是由于JavaScript的动态变量，上一秒可能是Array，下一秒就变成了Object。那么上一次引擎所做的优化，就失去了作用，此时又要再一次进行优化。</p><h3 id="asm-js出现" tabindex="-1"><a class="header-anchor" href="#asm-js出现" aria-hidden="true">#</a> asm.js出现</h3><p>所以为了解决这个问题，WebAssembly的前身，asm.js诞生了。asm.js是一个Javascript的严格子集，合理合法的asm.js代码一定是合理合法的JavaScript代码，但是反之就不成立。同WebAssembly一样，asm.js不是用来给各位用手<strong>一行一行撸</strong>的代码，asm.js是一个<strong>编译目标</strong>。它的可读性、可读性虽然比WebAssembly好，但是对于开发者来说，仍然是无法接受的。</p><p>asm.js强制静态类型，举个例子。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">asmJs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;use asm&#39;</span><span class="token punctuation">;</span>
    
    <span class="token keyword">let</span> myInt <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> myDouble <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">1.1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么asm.js会有静态类型呢？因为像<code>0 | 0</code>这样的，代表这是一个Int的数据，而<code>+1.1</code>则代表这是一个Double的数据。</p><h3 id="asm-js不能解决所有的问题" tabindex="-1"><a class="header-anchor" href="#asm-js不能解决所有的问题" aria-hidden="true">#</a> asm.js不能解决所有的问题</h3><p>可能有人有疑问，这问题不是解决了吗？那为什么会有WebAssembly？WebAssembly又解决了什么问题？大家可以再看一下上面的ChakraCore的引擎结构。无论asm.js对静态类型的问题做的再好，它始终逃不过要经过Parser，要经过ByteCode Compiler，而这两步是JavaScript代码在引擎执行过程当中消耗时间最多的两步。而WebAssembly不用经过这两步。这就是WebAssembly比asm.js更快的原因。</p><h3 id="webassembly横空出世" tabindex="-1"><a class="header-anchor" href="#webassembly横空出世" aria-hidden="true">#</a> WebAssembly横空出世</h3><p>所以在2015年，我们迎来了WebAssembly。WebAssembly是经过编译器编译之后的代码，体积小、起步快。在语法上完全脱离JavaScript，同时具有沙盒化的执行环境。WebAssembly同样的强制静态类型，是C/C++/Rust的编译目标。</p><h2 id="webassembly的优势" tabindex="-1"><a class="header-anchor" href="#webassembly的优势" aria-hidden="true">#</a> WebAssembly的优势</h2><h3 id="webassembly和asm-js性能对比" tabindex="-1"><a class="header-anchor" href="#webassembly和asm-js性能对比" aria-hidden="true">#</a> WebAssembly和asm.js性能对比</h3><p>下面的图是Unity WebGL使用和不使用WebAssembly的起步时间对比的一个BenchMark，给大家当作一个参考。<br> 可以看到，在FireFox中，WebAssembly和asm.js的性能差异达到了2倍，在Chrome中达到了3倍，在Edge中甚至达到了6倍。通过这些对比也可以从侧面看出，目前所有的主流浏览器都已经支持WebAssembly V1（Node &gt;= 8.0.0）.<br><img src="`+o+'" alt="" loading="lazy"></p><h3 id="与javascript做对比" tabindex="-1"><a class="header-anchor" href="#与javascript做对比" aria-hidden="true">#</a> 与JavaScript做对比</h3><p>我自己在一个用<code>create-react-app</code>新建的项目中，分别对比了WebAssembly版本和原生JavaScript版本的递归无优化的Fibonacci函数，下图是这两个函数在值是45、48、50的时候的性能对比。<br><img src="'+m+'" alt="img" loading="lazy"><br> 看图说话，这就是WebAssembly与JavaScript很实际的一个性能对比。几乎稳定的是JavaScript的两倍。</p><h2 id="webassembly在大型项目中的应用" tabindex="-1"><a class="header-anchor" href="#webassembly在大型项目中的应用" aria-hidden="true">#</a> WebAssembly在大型项目中的应用</h2><p>在这里能够举的例子还是很多，比如AutoCAD、GoogleEarth、Unity、Unreal、PSPDKit、WebPack等等。拿其中几个来简单说一下。</p><h3 id="autocad" tabindex="-1"><a class="header-anchor" href="#autocad" aria-hidden="true">#</a> AutoCAD</h3><p>这是一个用于画图的软件，在很长的一段时间是没有Web的版本的，原因有两个，其一，是Web的性能的确不能满足他们的需求。其二，在WebAssembly没有面世之前，AutoCAD是用C++实现的，要将其搬到Web上，就意味着要重写他们所有的代码，这代价十分的巨大。</p><p>而在WebAssembly面世之后，AutoCAD得以利用编译器，将其沉淀了30多年的代码直接编译成WebAssembly，同时性能基于之前的普通Web应用得到了很大的提升。正是这些原因，得以让AutoCAD将其应用从Desktop搬到Web中。</p><h3 id="google-earth" tabindex="-1"><a class="header-anchor" href="#google-earth" aria-hidden="true">#</a> Google Earth</h3><p>Google Earth也就是谷歌地球，因为需要展示很多3D的图像，对性能要求十分高，所以采取了一些Native的技术。最初的时候就连Google Chrome浏览器都不支持Web的版本，需要单独下载Google Earth的Destop应用。而在WebAssembly之后呢，谷歌地球推出了Web的版本。而据说下一个可以运行谷歌地球的浏览器是FireFox。</p><h3 id="unity和unreal游戏引擎" tabindex="-1"><a class="header-anchor" href="#unity和unreal游戏引擎" aria-hidden="true">#</a> Unity和Unreal游戏引擎</h3><p>这里给两个油管的链接自己体验一下，大家注意科学上网。</p>',45),v={href:"https://youtu.be/rIyIlATjNcE",target:"_blank",rel:"noopener noreferrer"},y={href:"https://www.youtube.com/watch?v=TwuIRcpeUWE",target:"_blank",rel:"noopener noreferrer"},g=i('<h2 id="webassembly要取代javascript" tabindex="-1"><a class="header-anchor" href="#webassembly要取代javascript" aria-hidden="true">#</a> WebAssembly要取代JavaScript？</h2><p>答案是否定的，请看下图。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>大家可以看到这是一个协作关系。WebAssembly是被设计成JavaScript的一个完善、补充，而不是一个替代品。WebAssembly将很多编程语言带到了Web中。但是JavaScript因其不可思议的能力，仍然将保留现有的地位。</p><h2 id="什么时候使用webassembly" tabindex="-1"><a class="header-anchor" href="#什么时候使用webassembly" aria-hidden="true">#</a> 什么时候使用WebAssembly？</h2><p>说了这么多，我到底什么时候该使用它呢？总结下来，大部分情况分两个点。</p><ul><li>对性能有很高要求的App/Module/游戏</li><li>在Web中使用C/C++/Rust/Go的库<br> 举个简单的例子。如果你要实现的Web版本的Ins或者Facebook， 你想要提高效率。那么就可以把其中对图片进行压缩、解压缩、处理的工具，用C++实现，然后再编译回WebAssembly。</li></ul><h2 id="webassembly的几个开发工具" tabindex="-1"><a class="header-anchor" href="#webassembly的几个开发工具" aria-hidden="true">#</a> WebAssembly的几个开发工具</h2>',8),f={href:"https://github.com/AssemblyScript/assemblyscript",target:"_blank",rel:"noopener noreferrer"},W={href:"https://github.com/kripken/emscripten",target:"_blank",rel:"noopener noreferrer"},A={href:"https://github.com/WebAssembly/wabt",target:"_blank",rel:"noopener noreferrer"},_=e("h2",{id:"webassembly的意义",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#webassembly的意义","aria-hidden":"true"},"#"),a(" WebAssembly的意义")],-1),x=e("p",null,"在我的个人理解上，WebAssembly并没有要替代JavaScript，一统天下的意思。我总结下来就两个点。",-1),w=e("ul",null,[e("li",null,"给了Web更好的性能"),e("li",null,[a("给了Web更多的可能"),e("br"),a(" 关于WebAssembly的性能问题，之前也花了很大的篇幅讲过了。而更多的可能，随着WebAssembly的技术越来越成熟，势必会有更多的应用，从Desktop被搬到Web上，这会使本来已经十分强大的Web更加丰富和强大。")])],-1),k=e("h2",{id:"webassembly实操",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#webassembly实操","aria-hidden":"true"},"#"),a(" WebAssembly实操")],-1),S={href:"https://github.com/kripken/emscripten",target:"_blank",rel:"noopener noreferrer"},j={href:"http://webassembly.org.cn/getting-started/developers-guide/",target:"_blank",rel:"noopener noreferrer"},C=i(`<h3 id="webassembly在node中的应用" tabindex="-1"><a class="header-anchor" href="#webassembly在node中的应用" aria-hidden="true">#</a> WebAssembly在Node中的应用</h3><h4 id="导入emscripten环境变量" tabindex="-1"><a class="header-anchor" href="#导入emscripten环境变量" aria-hidden="true">#</a> 导入Emscripten环境变量</h4><p>进入到你的emscripten安装目录，执行以下代码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">source</span> emsdk/emsdk_env.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="新建c文件" tabindex="-1"><a class="header-anchor" href="#新建c文件" aria-hidden="true">#</a> 新建C文件</h4><p>用C实现一个求和文件<code>test.c</code>，如下。</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>int add(int a, int b) {
	return a + b;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="使用emscripten编译c文件" tabindex="-1"><a class="header-anchor" href="#使用emscripten编译c文件" aria-hidden="true">#</a> 使用Emscripten编译C文件</h4><p>在同样的目录下执行如下代码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>emcc test.c <span class="token parameter variable">-Os</span> <span class="token parameter variable">-s</span> <span class="token assign-left variable">WASM</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-s</span> <span class="token assign-left variable">SIDE_MODULE</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-o</span> test.wasm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>emcc</code>就是Emscripten编译器，<code>test.c</code>是我们的输入文件，<code>-Os</code>表示这次编译需要优化，<code>-s WASM=1</code>表示输出wasm的文件，因为默认的是输出asm.js，<code>-s SIDE_MODULE=1</code>表示就只要这一个模块，不要给我其他乱七八糟的代码，<code>-o test.wasm</code>是我们的输出文件。</p><p>编译成功之后，当前目录下就会生成<code>test.wasm</code>。</p><h4 id="编写在node中调用的代码" tabindex="-1"><a class="header-anchor" href="#编写在node中调用的代码" aria-hidden="true">#</a> 编写在Node中调用的代码</h4><p>新建一个js文件<code>test.js</code>。代码如下。</p><div class="language-JavaScript line-numbers-mode" data-ext="JavaScript"><pre class="language-JavaScript"><code>const fs = require(&#39;fs&#39;);
let src = new Uint8Array(fs.readFileSync(&#39;./test.wasm&#39;));
const env = {
	memoryBase: 0,
	tableBase: 0,
	memory: new WebAssembly.Memory({
		initial: 256
	}),
	table: new WebAssembly.Table({
		initial: 2,
		element: &#39;anyfunc&#39;
	}),
	abort: () =&gt; {throw &#39;abort&#39;;}
}
WebAssembly.instantiate(src, {env: env})
.then(result =&gt; {
	console.log(result.instance.exports._add(20, 89));
})
.catch(e =&gt; console.log(e));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="执行test-js" tabindex="-1"><a class="header-anchor" href="#执行test-js" aria-hidden="true">#</a> 执行test.js</h4><p>运行以下代码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">node</span> test.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后就可以看到输出的结果109了。</p><h3 id="webassembly在react当中的应用" tabindex="-1"><a class="header-anchor" href="#webassembly在react当中的应用" aria-hidden="true">#</a> WebAssembly在React当中的应用</h3><h4 id="通过fetch的方法调用" tabindex="-1"><a class="header-anchor" href="#通过fetch的方法调用" aria-hidden="true">#</a> 通过fetch的方法调用</h4><p>直接用fetch的方式。大概的调用方式如下。</p><div class="language-JavaScript line-numbers-mode" data-ext="JavaScript"><pre class="language-JavaScript"><code>const fibonacciUrl = &#39;./fibonacci.wasm&#39;;
const {_fibonacci} = await this.getExportFunction(fibonacciUrl);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>而<code>getExportFunction</code>具体代码如下。</p><div class="language-JavaScript line-numbers-mode" data-ext="JavaScript"><pre class="language-JavaScript"><code>getExportFunction = async (url) =&gt; {
    const env = {
      memoryBase: 0,
      tableBase: 0,
      memory: new WebAssembly.Memory({
        initial: 256
      }),
      table: new WebAssembly.Table({
        initial: 2,
        element: &#39;anyfunc&#39;
      })
    };
    const instance = await fetch(url).then((response) =&gt; {
      return response.arrayBuffer();
    }).then((bytes) =&gt; {
      return WebAssembly.instantiate(bytes, {env: env})
    }).then((instance) =&gt; {
      return instance.instance.exports;
    });
    return instance;
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="通过import-c文件来调用" tabindex="-1"><a class="header-anchor" href="#通过import-c文件来调用" aria-hidden="true">#</a> 通过import C文件来调用</h4><p>先通过Import的方式来引进依赖。</p><div class="language-Javascript line-numbers-mode" data-ext="Javascript"><pre class="language-Javascript"><code>import wasmC from &#39;./add.c&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后进行调用。具体的方式如下。</p><div class="language-JavaScript line-numbers-mode" data-ext="JavaScript"><pre class="language-JavaScript"><code>wasmC({
  &#39;global&#39;: {},
  &#39;env&#39;: {
    &#39;memoryBase&#39;: 0,
    &#39;tableBase&#39;: 0,
    &#39;memory&#39;: new WebAssembly.Memory({initial: 256}),
    &#39;table&#39;: new WebAssembly.Table({initial: 0, element: &#39;anyfunc&#39;})
  }
}).then(result =&gt; {
  const exports = result.instance.exports;
  const add = exports._add;
  const fibonacci = exports._fibonacci;
  console.log(&#39;C return value was&#39;, add(2, 5643));
  console.log(&#39;Fibonacci&#39;, fibonacci(2));
});
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,30),J={href:"https://github.com/detectiveHLH/webassembly-in-react",target:"_blank",rel:"noopener noreferrer"},E=e("h2",{id:"写在后面",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#写在后面","aria-hidden":"true"},"#"),a(" 写在后面")],-1),B=e("p",null,"如今技术出现的越来越多，但是实际上在工作中能够用到的，越并不是那么多。其实很多大厂所输出的一些技术，都是有业务场景的，有业务做推动。而不是凭空造轮子。所以总结下来适合自己的才是最好的。当然不是说不要了解新技术，了解新技术跟上步伐是十分必要的。我们现在不用，不代表不需要了解。相反，以后再遇到类似的业务场景时，我们就会多一种选择，可以更加从容的对待。",-1);function D(I,M){const s=t("ExternalLinkIcon");return l(),d("div",null,[u,e("ul",null,[e("li",null,[a("Unity WebGL的戳"),e("a",v,[a("这里"),n(s)])]),e("li",null,[a("Unreal引擎的戳"),e("a",y,[a("这里"),n(s)])])]),g,e("ul",null,[e("li",null,[e("a",f,[a("AssemblyScript"),n(s)]),a("。支持直接将TypeScript编译成WebAssembly。这对于很多前端同学来说，入门的门槛还是很低的。")]),e("li",null,[e("a",W,[a("Emscripten"),n(s)]),a("。可以说是WebAssembly的灵魂工具不为过，上面说了很多编译，这个就是那个编译器。将其他的高级语言，编译成WebAssembly。")]),e("li",null,[e("a",A,[a("WABT"),n(s)]),a("。是个将WebAssembly在字节码和文本格式相互转换的一个工具，方便开发者去理解这个wasm到底是在做什么事。")])]),_,x,w,k,e("p",null,[a("要进行这个实际操作，你需要安装上文提到过的编译器"),e("a",S,[a("Emscripten"),n(s)]),a("，然后按照"),e("a",j,[a("这个"),n(s)]),a("步骤去安装。以下的步骤都默认为你已经安装了Emscripten。")]),C,e("p",null,[a("详细的代码在"),e("a",J,[a("这里"),n(s)]),a("，欢迎Star。")]),E,B])}const F=r(h,[["render",D],["__file","23092.html.vue"]]);export{F as default};
