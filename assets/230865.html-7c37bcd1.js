const e=JSON.parse(`{"key":"v-7c18c188","path":"/posts/230865.html","title":"降低代码的圈复杂度——复杂代码的解决之道","lang":"zh-CN","frontmatter":{"date":"2020-12-30T00:00:00.000Z","permalink":"/posts/230865.html","category":["后端"],"tag":["圈复杂度"],"description":"降低代码的圈复杂度——复杂代码的解决之道 本文代码示例以Go语言为例 0. 什么是圈复杂度 可能你之前没有听说过这个词，也会好奇这是个什么东西是用来干嘛的，在维基百科上有这样的解释。 Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's source code. It was developed by Thomas J. McCabe, Sr. in 1976.","head":[["meta",{"property":"og:url","content":"https://leonsh.cn/posts/230865.html"}],["meta",{"property":"og:site_name","content":"SH的全栈笔记"}],["meta",{"property":"og:title","content":"降低代码的圈复杂度——复杂代码的解决之道"}],["meta",{"property":"og:description","content":"降低代码的圈复杂度——复杂代码的解决之道 本文代码示例以Go语言为例 0. 什么是圈复杂度 可能你之前没有听说过这个词，也会好奇这是个什么东西是用来干嘛的，在维基百科上有这样的解释。 Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's source code. It was developed by Thomas J. McCabe, Sr. in 1976."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-02T08:48:07.000Z"}],["meta",{"property":"article:author","content":"LeonSH"}],["meta",{"property":"article:tag","content":"圈复杂度"}],["meta",{"property":"article:published_time","content":"2020-12-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-02T08:48:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"降低代码的圈复杂度——复杂代码的解决之道\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-12-30T00:00:00.000Z\\",\\"dateModified\\":\\"2023-09-02T08:48:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LeonSH\\",\\"url\\":\\"https://leonsh.cn\\"}]}"]]},"headers":[{"level":2,"title":"0. 什么是圈复杂度","slug":"_0-什么是圈复杂度","link":"#_0-什么是圈复杂度","children":[]},{"level":2,"title":"1. 为什么需要圈复杂度","slug":"_1-为什么需要圈复杂度","link":"#_1-为什么需要圈复杂度","children":[]},{"level":2,"title":"2. 圈复杂度度量标准","slug":"_2-圈复杂度度量标准","link":"#_2-圈复杂度度量标准","children":[{"level":3,"title":"2.1 节点判定法","slug":"_2-1-节点判定法","link":"#_2-1-节点判定法","children":[]},{"level":3,"title":"2.2 使用工具","slug":"_2-2-使用工具","link":"#_2-2-使用工具","children":[]}]},{"level":2,"title":"3. 如何降低圈复杂度","slug":"_3-如何降低圈复杂度","link":"#_3-如何降低圈复杂度","children":[{"level":3,"title":"3.1 拆分小函数","slug":"_3-1-拆分小函数","link":"#_3-1-拆分小函数","children":[]},{"level":3,"title":"3.2 少写流程控制语句","slug":"_3-2-少写流程控制语句","link":"#_3-2-少写流程控制语句","children":[]}]},{"level":2,"title":"4. 使用go-linq","slug":"_4-使用go-linq","link":"#_4-使用go-linq","children":[{"level":3,"title":"4.1 ForEach","slug":"_4-1-foreach","link":"#_4-1-foreach","children":[]},{"level":3,"title":"4.2 Where","slug":"_4-2-where","link":"#_4-2-where","children":[]},{"level":3,"title":"4.3 Distinct","slug":"_4-3-distinct","link":"#_4-3-distinct","children":[]},{"level":3,"title":"4.4 Except","slug":"_4-4-except","link":"#_4-4-except","children":[]},{"level":3,"title":"4.5 Intersect","slug":"_4-5-intersect","link":"#_4-5-intersect","children":[]},{"level":3,"title":"4.6 Select","slug":"_4-6-select","link":"#_4-6-select","children":[]},{"level":3,"title":"4.7 Group","slug":"_4-7-group","link":"#_4-7-group","children":[]}]},{"level":2,"title":"5. 关于go-linq的使用","slug":"_5-关于go-linq的使用","link":"#_5-关于go-linq的使用","children":[]}],"git":{"createdTime":1693644487000,"updatedTime":1693644487000,"contributors":[{"name":"leonsh","email":"detectivehlh@qq.com","commits":1}]},"readingTime":{"minutes":11.6,"words":3480},"filePathRelative":"posts/后端/降低代码的圈复杂度——复杂代码的解决之道.md","localizedDate":"2020年12月30日","excerpt":"<h1> 降低代码的圈复杂度——复杂代码的解决之道</h1>\\n<blockquote>\\n<p>本文代码示例以Go语言为例</p>\\n</blockquote>\\n<h2> 0. 什么是圈复杂度</h2>\\n<p>可能你之前没有听说过这个词，也会好奇这是个什么东西是用来干嘛的，在维基百科上有这样的解释。</p>\\n<blockquote>\\n<p><strong>Cyclomatic complexity</strong> is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's source code. It was developed by <strong>Thomas</strong> J. McCabe, Sr. in <strong>1976</strong>.</p>\\n</blockquote>","copyright":{"author":"LeonSH"},"autoDesc":true}`);export{e as data};
