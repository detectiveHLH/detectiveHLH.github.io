const e=JSON.parse('{"key":"v-7f8272c6","path":"/posts/230864.html","title":"缓存与数据库的双写一致性","lang":"zh-CN","frontmatter":{"date":"2021-06-11T00:00:00.000Z","permalink":"/posts/230864.html","category":["后端"],"tag":["缓存"],"description":"缓存与数据库的双写一致性 这几天瞎逛，不知道在哪里瞟到了缓存的双写，就突然想起来这块虽然简单，但是细节上还是有足够多我们可以去关注的点。这篇文章就来详细聊聊双写一致性。 首先我们知道，现在将高速缓存应用于业务当中已经十分常见了，甚至可能跟数据库的频率不相上下。你的用户量如果上去了，直接将一个裸的 MySQL 去扛住所有压力明显是不合理的。 这里的高速缓存，目前业界主流的就是 Redis 了，关于 Redis 相关的文章，之前也有聊过，在此就不赘述，感兴趣的可以看看：","head":[["meta",{"property":"og:url","content":"https://leonsh.cn/posts/230864.html"}],["meta",{"property":"og:site_name","content":"SH的全栈笔记"}],["meta",{"property":"og:title","content":"缓存与数据库的双写一致性"}],["meta",{"property":"og:description","content":"缓存与数据库的双写一致性 这几天瞎逛，不知道在哪里瞟到了缓存的双写，就突然想起来这块虽然简单，但是细节上还是有足够多我们可以去关注的点。这篇文章就来详细聊聊双写一致性。 首先我们知道，现在将高速缓存应用于业务当中已经十分常见了，甚至可能跟数据库的频率不相上下。你的用户量如果上去了，直接将一个裸的 MySQL 去扛住所有压力明显是不合理的。 这里的高速缓存，目前业界主流的就是 Redis 了，关于 Redis 相关的文章，之前也有聊过，在此就不赘述，感兴趣的可以看看："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-02T08:48:07.000Z"}],["meta",{"property":"article:author","content":"LeonSH"}],["meta",{"property":"article:tag","content":"缓存"}],["meta",{"property":"article:published_time","content":"2021-06-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-02T08:48:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"缓存与数据库的双写一致性\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-06-11T00:00:00.000Z\\",\\"dateModified\\":\\"2023-09-02T08:48:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LeonSH\\",\\"url\\":\\"https://leonsh.cn\\"}]}"]]},"headers":[{"level":2,"title":"Cache Aside Pattern","slug":"cache-aside-pattern","link":"#cache-aside-pattern","children":[{"level":3,"title":"具体方案","slug":"具体方案","link":"#具体方案","children":[]},{"level":3,"title":"为什么是删除","slug":"为什么是删除","link":"#为什么是删除","children":[]},{"level":3,"title":"争议在哪儿？","slug":"争议在哪儿","link":"#争议在哪儿","children":[]}]},{"level":2,"title":"End","slug":"end","link":"#end","children":[]}],"git":{"createdTime":1693644487000,"updatedTime":1693644487000,"contributors":[{"name":"leonsh","email":"detectivehlh@qq.com","commits":1}]},"readingTime":{"minutes":6.65,"words":1994},"filePathRelative":"posts/后端/缓存与数据库的双写一致性.md","localizedDate":"2021年6月11日","excerpt":"<h1> 缓存与数据库的双写一致性</h1>\\n<blockquote>\\n<p>这几天瞎逛，不知道在哪里瞟到了缓存的双写，就突然想起来这块虽然简单，但是细节上还是有足够多我们可以去关注的点。这篇文章就来详细聊聊<strong>双写一致性</strong>。</p>\\n</blockquote>\\n<p>首先我们知道，现在将高速缓存应用于业务当中已经十分常见了，甚至可能跟数据库的频率不相上下。你的用户量如果上去了，直接将一个裸的 MySQL 去扛住所有压力明显是不合理的。</p>\\n<p>这里的高速缓存，目前业界主流的就是 Redis 了，关于 Redis 相关的文章，之前也有聊过，在此就不赘述，感兴趣的可以看看：</p>","copyright":{"author":"LeonSH"},"autoDesc":true}');export{e as data};
