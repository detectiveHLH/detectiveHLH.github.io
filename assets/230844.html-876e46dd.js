import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as e,c as o,a as s,b as n,d as c,f as l}from"./app-3ad9ab44.js";const i={},u=s("h1",{id:"深入了解concurrenthashmap",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#深入了解concurrenthashmap","aria-hidden":"true"},"#"),n(" 深入了解ConcurrentHashMap")],-1),k={href:"https://mp.weixin.qq.com/s/-ZE8eA-2CFYsgwRbwjEVnw",target:"_blank",rel:"noopener noreferrer"},r=l(`<p>我们知道，HashMap是非线程安全的容器，那么为什么ConcurrentHashMap能够做到线程安全呢？</p><h2 id="底层结构" tabindex="-1"><a class="header-anchor" href="#底层结构" aria-hidden="true">#</a> 底层结构</h2><p>首先看一下ConcurrentHashMap的底层数据结构，在Java8中，其底层的实现方式与HashMap一样的，同样是数组、链表再加红黑树，具体的可以参考上面的HashMap的文章，下面所有的讨论都是基于Java 1.8。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="volatile关键字" tabindex="-1"><a class="header-anchor" href="#volatile关键字" aria-hidden="true">#</a> volatile关键字</h3><p>对比HashMap的底层结构可以发现，table的定义中多了一个<strong>volatile</strong>关键字。这个关键字是做什么的呢？我们知道所有的共享变量都存在<strong>主内存</strong>中，就像table。</p><p>而线程对变量的所有操作都必须在线程自己的<strong>工作内存</strong>中完成，而不能直接读取主存中的变量，这是JMM的规定。所以每个线程都会有自己的工作内存，工作内存中存放了共享变量的副本。而正是因为这样，才造成了可见性的问题。</p><p>ABCD四个线程同时在操作一个共享变量X，此时如果A从主存中读取了X，改变了值，并且写回了内存。那么BCD线程所得到的X副本就已经失效了。此时如果没有被<strong>volatile</strong>修饰，那么BCD线程是不知道自己的变量副本已经失效了。继续使用这个变量就会造成<strong>数据不一致</strong>的问题。</p><h3 id="内存可见性" tabindex="-1"><a class="header-anchor" href="#内存可见性" aria-hidden="true">#</a> 内存可见性</h3><p>而如果加上了volatile关键字，BCD线程就会立马看到最新的值，这就是<strong>内存可见性</strong>。你可能想问，凭什么加了volatile的关键字就可以保证共享变量的内存可见性？</p><p>那是因为如果变量被volatile修饰，在线程进行<strong>写操作</strong>时，会直接将新的值写入到主存中，而不是线程的工作内存中；而在<strong>读操作</strong>时，会直接从主存中读取，而不是线程的工作内存。</p><h2 id="基础使用" tabindex="-1"><a class="header-anchor" href="#基础使用" aria-hidden="true">#</a> 基础使用</h2><p>首先这个使用与HashMap没有任何区别，只是实现改成了ConcurrentHashMap。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;微信搜索&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;SH的全栈笔记&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;微信搜索&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// SH的全栈笔记</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="取值" tabindex="-1"><a class="header-anchor" href="#取值" aria-hidden="true">#</a> 取值</h3><p>首先我们来看一下get方法的使用，源码如下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
  <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>
          <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大概解释一下这个过程发生了什么，首先根据key计算出哈希值，如果找到了就直接返回值。如果是红黑树的话，就在红黑树中查找值，否则就按照链表的查找方式查找。</p><p>这与HashMap也差不多的，元素会首先以链表的方式进行存储，如果该桶中的元素数量大于<code>TREEIFY_THRESHOLD</code>的值，就会触发树化。将当前的链表转换为红黑树。因为如果数量太多的话，链表的查询效率就会变得非常低，时间复杂度为O(n)，而红黑树的查询时间复杂度则为O(logn)，这个阈值在Java 1.8中的默认值为8，定义如下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="赋值" tabindex="-1"><a class="header-anchor" href="#赋值" aria-hidden="true">#</a> 赋值</h3><p><code>put</code>的源码就不放出来了，放在这大家估计也不会一行一行的去看。所以我就简单的解释一下put的过程发生了什么事，并贴上关键代码就好了。</p><p>整个过程，除开并发的一些细节，大致的流程和1.8中的HashMap是差不多的。</p><ul><li>首先会根据传入的key计算出hashcode，如果是第一次被赋值，那自然需要进行初始化table</li><li>如果这个key没有存在过，直接用CAS在当前槽位的头节点创建一个Node，会用自旋来保证成功</li><li>如果当前的Node的hashcode是否等于-1，如果是则证明有其它的线程正在执行扩容操作，当前线程就加入到扩容的操作中去</li><li>且如果该槽位（也就是桶）上的数据结构如果是链表，则按照链表的插入方式，直接接在当前的链表的后面。如果数量大于了树化的阈值就会转为红黑树。</li><li>如果这个key存在，就会直接覆盖。</li><li>判断是否需要扩容</li></ul><p>看到这你可能会有一堆的疑问。</p><blockquote><p>例如在多线程的情况下，几个线程同时来执行put操作时，怎么保证只执行一次初始化，或者怎么保证只执行一次扩容呢？万一我已经写入了数据，另一个线程又初始化了一遍，岂不是造成了数据不一致的问题。同样是多线程的情况下， 怎么保证put值的时候不会被其他线程覆盖。CAS又是什么？</p></blockquote><p>接下来我们就来看一下在多线程的情况下，<code>ConcurrentHashMap</code>是如何保证线程安全的。</p><h2 id="初始化的线程安全" tabindex="-1"><a class="header-anchor" href="#初始化的线程安全" aria-hidden="true">#</a> 初始化的线程安全</h2><p>首先我们来看初始化的源码。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>
          <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
          <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
          table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
          sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> tab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到有一个关键的变量，<code>sizeCtl</code>，其定义如下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>sizeCtl使用了关键字<code>volatile</code>修饰，说明这是一个多线程的共享变量，可以看到如果是首次初始化，第一个判断条件<code>if ((sc = sizeCtl) &lt; 0)</code>是不会满足的，正常初始化的话sizeCtl的值为0，初始化设定了size的话sizeCtl的值会等于传入的size，而这两个值始终是大于0的。</p><h3 id="cas" tabindex="-1"><a class="header-anchor" href="#cas" aria-hidden="true">#</a> CAS</h3><p>然后就会进入下面的<code>U.compareAndSwapInt(this, SIZECTL, sc, -1)</code>方法，这就是上面提到的<strong>CAS</strong>，Compare and Swap（Set），比较并交换，Unsafe是位于<code>sun.misc</code>下的一个类，在Java底层用的比较多，它让Java拥有了类似C语言一样直接操作内存空间的能力。</p><p>例如可以操作内存、CAS、内存屏障、线程调度等等，但是如果Unsafe类不能被正确使用，就会使程序变的不安全，所以不建议程序直接使用它。</p><p><code>compareAndSwapInt</code>的四个参数分别是，实例、偏移地址、预期值、新值。偏移地址可以快速帮我们在实例中定位到我们要修改的字段，此例中便是<code>sizeCtl</code>。如果内存当中的sizeCtl是传入的预期值，则将其更新为新的值。这个Unsafe类的方法可以保证这个操作的<strong>原子性</strong>。当你在使用parallelStream进行并发的foreach遍历时，如果涉及到修改一个整型的共享变量时，你肯定不能直接用i++，因为在多线程下，i++每次操作不能保证原子性。所以你可能会用到如下的方式。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">AtomicInteger</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">-&gt;</span> num<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能会好奇，为什么使用了<code>AtomicInteger</code>就可以保证原子性，跟Unsafe类和CAS又有什么关系，让我们接着往下，看<code>getAndIncrement</code>方法的底层实现。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，底层调用的是Unsafe类的方法，这不就联系上了吗，而<code>getAndIncrement</code>的实现又长这样。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没错，这里底层调用了<code>compareAndSwapInt</code>方法。可以看到这里加了while，如果该方法返回false就一直循环，直到成功为止。这个过程有个🐂🍺的名字，叫<strong>自旋</strong>。特别高端啊，说人话就是无限循环。</p><p>什么情况会返回false呢？那就是<code>var5</code>变量存储的值，和现在内存中实际<code>var5</code>的值<strong>不同</strong>，说明这个变量已经被其他线程修改过了，此时通过自旋来重新获取，直到成功为止，然后自旋结束。</p><h3 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h3><p>聊的稍微有点多，这小节的问题是如何保证不重复初始化。那就是执行首次扩容时，会将变量<code>sizeCtl</code>设置为<code>-1</code>，因为其被<code>volatile</code>修饰，所以其值的修改对其他线程可见。</p><p>其它线程再调用初始化时，就会发现<code>sizeCtl</code>的值为<code>-1</code>，说明已经有线程正在执行初始化的操作了，就会执行<code>Thread.yield()</code>，然后退出。</p><p><code>yield</code>相信大家都不陌生，和<code>sleep</code>不同，<code>sleep</code>可以让线程进入阻塞状态，且可以指定阻塞的时间，同时释放CPU资源。而<code>yield</code>不会让线程进入阻塞状态，而且也不能指定时间，它让线程重新进入可执行状态，让出CPU调度，让CPU资源被同优先级或者高优先级的线程使用，稍后再进行尝试，这个时间依赖于当前CPU的时间片划分。</p><h2 id="如何保证值不被覆盖" tabindex="-1"><a class="header-anchor" href="#如何保证值不被覆盖" aria-hidden="true">#</a> 如何保证值不被覆盖</h2><p>我们在上一节举了在并发下i++的例子，说在并发下i++并不是一个具有<strong>原子性</strong>的操作，假设此时<code>i=1</code>，线程A和线程B同时取了i的值，同时+1，然后此时又同时的写回。那么此时<code>i++</code>的值会是2而不是3，在并发下<code>1+1+1=2</code>是可能出现的。</p><p>让我们来看一下<code>ConcurrentHashMap</code>在目标key已经存在时的赋值操作，因为如果不存在会直接调用Unsafe的方法创建一个Node，所以后续的线程就会进入到下面的逻辑中来，由于太长，我省略了一些代码。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>
      binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
          p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span>
    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码在赋值的逻辑外层包了一个<code>synchronized</code>，这个有什么用呢？</p><h3 id="synchronized关键字" tabindex="-1"><a class="header-anchor" href="#synchronized关键字" aria-hidden="true">#</a> synchronized关键字</h3><p>这个地方也可以换一个方式来理解，那就是<code>synchronized</code>如何保证线程安全的。线程安全，我认为更多的是描述一种<strong>风险</strong>。在堆内存中的数据由于可以被任何线程访问到，在没有任何限制的情况下存在被意外修改的风险。</p><p>而<code>synchronized</code>是通过对共享资源加锁的方式，使同一时间只能有一个线程能够访问到临界区（也就是共享资源），共享资源包括了方法、锁代码块和对象。</p><p>那是不是使用了<code>synchronized</code>就一定能保证线程安全呢？不是的，如果不能正确的使用，很可能就会引发死锁，所以，保证线程安全的前提是<strong>正确的使用</strong><code>synchronized</code>。</p><h2 id="自动扩容的线程安全" tabindex="-1"><a class="header-anchor" href="#自动扩容的线程安全" aria-hidden="true">#</a> 自动扩容的线程安全</h2><p>除了初始化、并发的写入值，还有一个问题值得关注，那就是在多线程下，<code>ConcurrentHashMap</code>是如何保证自动扩容是线程安全的。</p><p>扩容的关键方案是<code>transfer</code>，但是由于代码太多了，贴在这个地方可能会影响大家的理解，感兴趣的可以自己的看一下。</p><p>还是大概说一下自动扩容的过程，我们以一个线程来举例子。在<code>putVal</code>的最后一步，会调用<code>addCount</code>方法，然后在方法里判读是否需要扩容，如果容量超过了<code>实际容量 * 负载因子</code>（也就是sizeCtl的值）就会调用<code>transfer</code>方法。</p><h3 id="计算分区的范围" tabindex="-1"><a class="header-anchor" href="#计算分区的范围" aria-hidden="true">#</a> 计算分区的范围</h3><p>因为<code>ConcurrentHashMap</code>是支持多线程同时扩容的，所以为了避免每个线程处理的数量不均匀，也为了提高效率，其对当前的所有桶按数量（也就是上面提到的槽位）进行分区，每个线程只处理自己分到的区域内的桶的数据即可。</p><p>当前线程计算当前stride的代码如下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>stride <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">NCPU</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">NCPU</span> <span class="token operator">:</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果计算出来的值小于设定的最小范围，也就是<code>private static final int MIN_TRANSFER_STRIDE = 16;</code>，就把当前分区范围设置为16。</p><h3 id="初始化nexttable" tabindex="-1"><a class="header-anchor" href="#初始化nexttable" aria-hidden="true">#</a> 初始化nextTable</h3><p><code>nextTable</code>也是一个共享变量，定义如下，用于存放在正在扩容之后的<code>ConcurrentHashMap</code>的数据，当且仅当正在<strong>扩容</strong>时才不为空。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果当前transfer方法传入的nextTab（这是个局部变量，比上面提到的nextTable少了几个字母，不要搞混了）是null，说明是当前线程是第一个调用扩容操作的线程，就需要初始化一个size为原来容量2被的nextTable，核心代码如下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 可以看到传入的初始化容量是n &lt;&lt; 1。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>初始化成功之后就更新<strong>共享变量</strong><code>nextTable</code>的值，并设置<code>transferIndex</code>的值为扩容前的length，这也是一个共享的变量，表示扩容使还未处理的桶的下标。</p><h3 id="设置分区边界" tabindex="-1"><a class="header-anchor" href="#设置分区边界" aria-hidden="true">#</a> 设置分区边界</h3><p>一个新的线程加入扩容操作，在完成上述步骤后，就会开始从现在正在扩容的Map中找到自己的分区。例如，如果是第一个线程，那么其取到的分区就会如下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>start <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
end <span class="token operator">=</span> nextIndex <span class="token operator">&gt;</span> stride <span class="token operator">?</span> nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 实际上就是当还有足够的桶可以分的时候，线程分到的分区为 [n-stride, n - 1]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，分区是从尾到首进行的。而如果是首次进入的线程，<code>nextIndex</code> 的值会被初始化为共享变量<code>transferIndex</code> 的值。</p><h3 id="copy分区内的值" tabindex="-1"><a class="header-anchor" href="#copy分区内的值" aria-hidden="true">#</a> Copy分区内的值</h3><p>当前线程在自己划分到的分区内开始遍历，如果当前桶是null，那么就生成一个 <code>ForwardingNode</code>，代码如下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>并把当前槽位赋值为fwd，你可以把<code>ForwardingNode</code>理解为一个标志位，如果有线程遍历到了这个桶， 发现已经是<code>ForwardingNode</code>了，就代表这个桶已经被处理过了，就会跳过这个桶。</p><p>如果这个桶没有被处理过，就会开始给当前的桶加锁，我们知道<code>ConcurrentHashMap</code>会在多线程的场景下使用，所以当有线程正在扩容的时候，可能还会有线程正在执行put操作，所以如果当前Map正在执行扩容操作，如果此时再写入数据，很可能会造成的数据丢失，所以要对桶进行加锁。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>对比在1.7中采用的<code>Segment</code>分段锁的臃肿设计，1.8中直接使用了<code>CAS</code>和<code>Synchronized</code>来保证并发下的线程安全。总的来说，在1.8中，ConcurrentHashMap和HashMap的底层实现都差不多，都是数组、链表和红黑树的方式。其主要区别就在于应用场景，非并发的情况可以使用HashMap，而如果要处理并发的情况，就需要使用ConcurrentHashMap。关于ConcurrentHashMap就先聊到这里。</p>`,83);function d(v,m){const a=t("ExternalLinkIcon");return e(),o("div",null,[u,s("p",null,[n("在上一篇文章"),s("a",k,[n("【简单了解系列】从基础的使用来深挖HashMap"),c(a)]),n("里，我从最基础的使用中介绍了HashMap，大致是JDK1.7和1.8中底层实现的变化，和介绍了为什么在多线程下可能会造成死循环，扩容机智是什么样的。感兴趣的可以先看看。")]),r])}const g=p(i,[["render",d],["__file","230844.html.vue"]]);export{g as default};
