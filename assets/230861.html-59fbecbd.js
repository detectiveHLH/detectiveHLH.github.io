const e=JSON.parse('{"key":"v-89bf8680","path":"/posts/230861.html","title":"两分钟让你明白Go中如何继承","lang":"zh-CN","frontmatter":{"date":"2019-10-25T00:00:00.000Z","permalink":"/posts/230861.html","category":["Golang"],"tag":["继承"],"description":"两分钟让你明白Go中如何继承 最近在重构代码的时候，抽象了大量的接口。也使用这些抽象的接口做了很多伪继承的操作，极大的减少了代码冗余，同时也增加了代码的可读性。 然后随便搜了一下关于Go继承的文章，发现有的文章的代码量过多，并且代码format极其粗糙，命名极其随意，类似于A、B这种，让人看着看着就忘了到底是谁继承谁，我又要回去看一遍逻辑。 虽然只是样例代码，我认为仍然需要做到简洁、清晰以及明了。这也是我为什么要写这篇博客的原因。接下里在这里简单分享一下在Go中如何实现继承。 1. 简单的组合 说到继承我们都知道，在Go中没有extends关键字，也就意味着Go并没有原生级别的继承支持。这也是为什么我在文章开头用了伪继承这个词。本质上，Go使用interface实现的功能叫组合，Go是使用组合来实现的继承，说的更精确一点，是使用组合来代替的继承，举个很简单的例子。","head":[["meta",{"property":"og:url","content":"https://leonsh.cn/posts/230861.html"}],["meta",{"property":"og:site_name","content":"SH的全栈笔记"}],["meta",{"property":"og:title","content":"两分钟让你明白Go中如何继承"}],["meta",{"property":"og:description","content":"两分钟让你明白Go中如何继承 最近在重构代码的时候，抽象了大量的接口。也使用这些抽象的接口做了很多伪继承的操作，极大的减少了代码冗余，同时也增加了代码的可读性。 然后随便搜了一下关于Go继承的文章，发现有的文章的代码量过多，并且代码format极其粗糙，命名极其随意，类似于A、B这种，让人看着看着就忘了到底是谁继承谁，我又要回去看一遍逻辑。 虽然只是样例代码，我认为仍然需要做到简洁、清晰以及明了。这也是我为什么要写这篇博客的原因。接下里在这里简单分享一下在Go中如何实现继承。 1. 简单的组合 说到继承我们都知道，在Go中没有extends关键字，也就意味着Go并没有原生级别的继承支持。这也是为什么我在文章开头用了伪继承这个词。本质上，Go使用interface实现的功能叫组合，Go是使用组合来实现的继承，说的更精确一点，是使用组合来代替的继承，举个很简单的例子。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-02T08:48:07.000Z"}],["meta",{"property":"article:author","content":"LeonSH"}],["meta",{"property":"article:tag","content":"继承"}],["meta",{"property":"article:published_time","content":"2019-10-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-02T08:48:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"两分钟让你明白Go中如何继承\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-10-25T00:00:00.000Z\\",\\"dateModified\\":\\"2023-09-02T08:48:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LeonSH\\",\\"url\\":\\"https://leonsh.cn\\"}]}"]]},"headers":[{"level":2,"title":"1. 简单的组合","slug":"_1-简单的组合","link":"#_1-简单的组合","children":[{"level":3,"title":"1.1 实现父类","slug":"_1-1-实现父类","link":"#_1-1-实现父类","children":[]},{"level":3,"title":"1.2 代码分析","slug":"_1-2-代码分析","link":"#_1-2-代码分析","children":[]}]},{"level":2,"title":"2. 优雅的组合","slug":"_2-优雅的组合","link":"#_2-优雅的组合","children":[{"level":3,"title":"2.1 抽象接口","slug":"_2-1-抽象接口","link":"#_2-1-抽象接口","children":[]},{"level":3,"title":"2.2 重载方法","slug":"_2-2-重载方法","link":"#_2-2-重载方法","children":[]},{"level":3,"title":"2.3 参数多态","slug":"_2-3-参数多态","link":"#_2-3-参数多态","children":[]}]},{"level":2,"title":"3. 总结","slug":"_3-总结","link":"#_3-总结","children":[]}],"git":{"createdTime":1693644487000,"updatedTime":1693644487000,"contributors":[{"name":"leonsh","email":"detectivehlh@qq.com","commits":1}]},"readingTime":{"minutes":6.21,"words":1864},"filePathRelative":"posts/Golang/两分钟让你明白Go中如何继承.md","localizedDate":"2019年10月25日","excerpt":"<h1> 两分钟让你明白Go中如何继承</h1>\\n<p>最近在重构代码的时候，抽象了大量的接口。也使用这些抽象的接口做了很多伪继承的操作，极大的减少了代码冗余，同时也增加了代码的可读性。</p>\\n<p>然后随便搜了一下关于Go继承的文章，发现有的文章的代码量过多，并且代码format极其粗糙，命名极其随意，类似于A、B这种，让人看着看着就忘了到底是谁继承谁，我又要回去看一遍逻辑。</p>\\n<p>虽然只是样例代码，我认为仍然需要做到简洁、清晰以及明了。这也是我为什么要写这篇博客的原因。接下里在这里简单分享一下在Go中如何实现继承。</p>\\n<h2> 1. 简单的组合</h2>\\n<p>说到继承我们都知道，在Go中没有<code>extends</code>关键字，也就意味着Go并没有原生级别的继承支持。这也是为什么我在文章开头用了<strong>伪继承</strong>这个词。本质上，Go使用interface实现的功能叫组合，Go是使用组合来实现的继承，说的更精确一点，是使用组合来代替的继承，举个很简单的例子。</p>","copyright":{"author":"LeonSH"},"autoDesc":true}');export{e as data};
